# Jenkins + Docker Deployment Guide (for `sample-java-application`)

This guide walks you through a complete CI/CD setup to build and deploy a Java web app (WAR) to **Tomcat** inside Docker using **Jenkins**. It includes:

- Installing **Git**, **Docker**, **Jenkins** and dependencies on Ubuntu
- Forking the reference app and creating **your own** GitHub repo
- Writing a **Dockerfile** (Ubuntu + Tomcat)
- Creating a **Jenkins Pipeline** (`Jenkinsfile`) that builds, pushes, and runs the container
- **Jenkins UI** configuration: plugins & credentials
- **Troubleshooting** common errors (permissions, ports, credentials, downloads, etc.)

---

## ðŸ”­ What youâ€™ll build
**Flow:** GitHub (your fork) â†’ Jenkins (build WAR + image) â†’ Docker Hub (push) â†’ Jenkins host (run) â†’ Browser access

- Final app URL: `http://<jenkins-host-ip>:9090/app` (or your app context)

---

## âœ… Prerequisites
- **Ubuntu 22.04 LTS** VM (AWS EC2 or local) with **2 vCPU / 4GB RAM** minimum
- GitHub & Docker Hub accounts
- Open inbound security group/firewall for **TCP 8080 (Jenkins UI)** and **TCP 9090 (your app)**

> If Jenkins runs on a different VM from Docker, repeat the Docker install on that VM too. Easiest path: **run Jenkins and Docker on the same host.**

---

## 1) System setup on Ubuntu

### 1.1 Install Git
```bash
sudo apt update
sudo apt install -y git
git --version
```

### 1.2 Install Docker (Engine + CLI)
```bash
# Prereqs
sudo apt-get install -y ca-certificates curl gnupg lsb-release

# Dockerâ€™s official GPG key
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

# Stable repo
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Install
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# Enable service
sudo systemctl enable --now docker

# Allow your user and the Jenkins user to run docker
sudo usermod -aG docker $USER
sudo usermod -aG docker jenkins || true

# Apply group changes for current shell
newgrp docker

# Test
docker run --rm hello-world
```

### 1.3 Install Jenkins (LTS)
```bash
# Java (Jenkins supports Java 11 or 17; we use 11 here)
sudo apt install -y openjdk-11-jdk

# Jenkins repo + key
curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key | sudo tee /usr/share/keyrings/jenkins-keyring.asc > /dev/null
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list > /dev/null

# Install Jenkins
sudo apt update
sudo apt install -y jenkins
sudo systemctl enable --now jenkins

# Get initial admin password
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
```
Open the UI at: `http://<server-ip>:8080` â†’ **Unlock Jenkins** â†’ **Install suggested plugins**.

> **Important:** After adding `jenkins` to the `docker` group above, restart Jenkins so it picks up the new group membership:
```bash
sudo systemctl restart jenkins
```

---

## 2) Prepare your application repository

### 2.1 Fork the sample app
1. Open: `https://github.com/arjunpilakkal/sample-java-application`
2. Click **Fork** â†’ your GitHub account.
3. Your fork URL will look like: `https://github.com/<your-username>/sample-java-application`

### 2.2 Clone your fork to a workstation (or the Jenkins host)
```bash
git clone https://github.com/<your-username>/sample-java-application.git
cd sample-java-application
```

### 2.3 (Optional) Verify you can build a WAR locally
This repo typically contains a Maven Wrapper (`mvnw`). If not, use `mvn` (install Maven with `sudo apt install -y maven`).
```bash
# with wrapper
chmod +x mvnw
./mvnw clean package -DskipTests

# or with system Maven
mvn clean package -DskipTests

ls -lh target/*.war
```

---

## 3) Add a Dockerfile (Ubuntu + Tomcat)
Create `Dockerfile` in the repo root:
```dockerfile
# Base Ubuntu and Java
FROM ubuntu:22.04
ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update \
 && apt-get install -y openjdk-11-jdk wget \
 && rm -rf /var/lib/apt/lists/*

# Install Apache Tomcat (pin a current version)
RUN wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.108/bin/apache-tomcat-9.0.108.tar.gz \
 && tar xzf apache-tomcat-9.0.108.tar.gz \
 && mv apache-tomcat-9.0.108 /opt/tomcat \
 && rm apache-tomcat-9.0.108.tar.gz

# Copy the built WAR into Tomcat
# If your artifact name differs, adjust the pattern below
COPY target/*.war /opt/tomcat/webapps/app.war

EXPOSE 8080
CMD ["/opt/tomcat/bin/catalina.sh", "run"]
```
(Optional) `.dockerignore`:
```
.git
.gitignore
*.md
*.log
node_modules/
target/
```
Commit and push this to **your fork**.

---

## 4) Jenkins UI configuration (plugins & credentials)

### 4.1 Install required plugins
Jenkins â†’ **Manage Jenkins** â†’ **Plugins** â†’ **Available** tab â†’ install:
- **Pipeline** (Declarative + Groovy pipeline support)
- **Git** (SCM)
- **Credentials Binding** (safe secret injection)
- **Docker Pipeline** (optional, but helpful)
- *(Optional)* **Timestamper**, **AnsiColor**, **Workspace Cleanup**, **Blue Ocean**

Restart Jenkins if prompted.

### 4.2 Add credentials (Docker Hub, optional GitHub)
Jenkins â†’ **Manage Jenkins** â†’ **Credentials** â†’ **System** â†’ **Global credentials (unrestricted)** â†’ **Add Credentials**:

**A) Docker Hub**
- **Kind:** Username with password  
- **ID:** `dockerhub` *(use exactly this ID to match the Jenkinsfile below)*  
- **Username:** `<your-dockerhub-username>`  
- **Password:** *(Docker Hub access token with **Read & Write** access)*  

**B) GitHub (optional, only if your fork is private)**
- **Kind:** Username with password (or **Secret text** for a PAT)  
- **ID:** `github`  
- **Username:** `<your-github-username>`  
- **Password/Token:** `<your-PAT-with-repo-scope>`

### 4.3 Verify Docker access from Jenkins
Create a **Freestyle** job â†’ **Build step: Execute shell**:
```bash
docker --version
id
```
Run the job â€” it should succeed and show Docker version. If you see `permission denied` on `/var/run/docker.sock`, re-run:
```bash
sudo usermod -aG docker jenkins
sudo systemctl restart jenkins
```

---

## 5) Jenkins Pipeline (`Jenkinsfile`)
Create `Jenkinsfile` in your repo root and push it. The pipeline will:
1) Clone your fork  
2) Build the WAR  
3) Build & push Docker image to Docker Hub  
4) Run the container on port **9090** (to avoid clashing with Jenkins 8080)

```groovy
pipeline {
  agent any

  environment {
    DOCKERHUB_USER = '<your-dockerhub-username>'   // change this
    IMAGE_NAME     = 'sample-java-application'
    IMAGE_TAG      = 'latest'
  }

  options { timestamps() }

  stages {
    stage('Checkout') {
      steps {
        // If your fork is private, add credentials: credentialsId: 'github'
        git branch: 'main', url: 'https://github.com/<your-username>/sample-java-application.git'
      }
    }

    stage('Build WAR') {
      steps {
        sh 'chmod +x mvnw || true'
        sh './mvnw -v || mvn -v'
        sh './mvnw clean package -DskipTests || mvn clean package -DskipTests'
      }
    }

    stage('Build Docker Image') {
      steps {
        sh 'DOCKER_BUILDKIT=1 docker build -t $DOCKERHUB_USER/$IMAGE_NAME:$IMAGE_TAG .'
      }
    }

    stage('Push to Docker Hub') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
          sh 'echo $PASS | docker login -u $USER --password-stdin'
          sh 'docker push $DOCKERHUB_USER/$IMAGE_NAME:$IMAGE_TAG'
        }
      }
    }

    stage('Run Container') {
      steps {
        sh 'docker rm -f sample-app || true'
        sh 'docker run -d --name sample-app -p 9090:8080 $DOCKERHUB_USER/$IMAGE_NAME:$IMAGE_TAG'
      }
    }
  }

  post {
    always { sh 'docker logout || true' }
  }
}
```

### 5.1 Create the Jenkins job
- Jenkins â†’ **New Item** â†’ **Pipeline** â†’ name it `sample-java-pipeline` â†’ **OK**
- **Pipeline** â†’ **Definition:** *Pipeline script from SCM*
  - **SCM:** Git
  - **Repository URL:** `https://github.com/<your-username>/sample-java-application.git`
  - **Credentials:** *(select `github` if private; otherwise leave blank)*
  - **Branch Specifier:** `*/main`
  - **Script Path:** `Jenkinsfile`
- **Save** â†’ **Build Now**

---

## 6) Verify deployment

### 6.1 Check container
```bash
docker ps
```
Expected mapping: `0.0.0.0:9090->8080/tcp` with container name `sample-app`.

### 6.2 Test locally on the Jenkins host
```bash
curl -I http://localhost:9090/
```

### 6.3 Test from your browser
Visit: `http://<jenkins-host-ip>:9090/app` (or the correct context path for your app)

> If unreachable, open firewall/security group for **TCP 9090** on the VM.

---

## 7) Troubleshooting (quick fixes)

| Symptom / Error | Likely Cause | Fix |
|---|---|---|
| `permission denied while connecting to Docker daemon` | `jenkins` not in `docker` group | `sudo usermod -aG docker jenkins && sudo systemctl restart jenkins` |
| `bind: address already in use :8080` | Jenkins uses 8080; port conflict | Map to another host port: `-p 9090:8080` (as in the pipeline) |
| `unauthorized: access token has insufficient scopes` (docker push) | Docker Hub token is read-only | Create a **Read & Write** access token and update Jenkins credential `dockerhub` |
| `repository does not exist or may require 'docker login'` | Not logged in or wrong repo name | Verify `docker login`, ensure repo path `$DOCKERHUB_USER/$IMAGE_NAME` is correct |
| `404 Not Found` while downloading Tomcat | Version URL changed | Update Dockerfile to a current Tomcat (e.g., `9.0.108`) |
| `./mvnw: not found` in Jenkins | Project missing Maven Wrapper | Install Maven on host (`sudo apt install -y maven`) and use `mvn` path in Jenkinsfile |
| App not reachable from Internet | Firewall/Security Group closed | Open inbound TCP **9090** to your IP or 0.0.0.0/0 as appropriate |
| Disk full during build | Docker layers piling up | `docker system prune -f` (careful!), add `.dockerignore` |

---

## 8) Extras & best practices
- **Tag images per build** for rollbacks:
  ```groovy
  def tag = "${env.BUILD_NUMBER}"
  sh 'docker tag $DOCKERHUB_USER/$IMAGE_NAME:latest $DOCKERHUB_USER/$IMAGE_NAME:' + tag
  sh 'docker push $DOCKERHUB_USER/$IMAGE_NAME:' + tag
  ```
- **Run on port 80** (optional): `docker run -p 80:8080 ...` (ensure nothing else uses 80)
- **Non-root in container** (hardening):
  ```dockerfile
  RUN useradd -m appuser && chown -R appuser:appuser /opt/tomcat
  USER appuser
  ```
- **Healthcheck** example:
  ```dockerfile
  HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- http://localhost:8080/ || exit 1
  ```
- **Webhook trigger**: Configure a GitHub webhook to Jenkins URL `http://<jenkins-ip>:8080/github-webhook/` for auto-builds on push.

---

## 9) What to submit (typical assignment)
- `README.md` (this file) in your fork
- `Dockerfile` and `Jenkinsfile`
- Screenshot of Jenkins **successful pipeline**
- Screenshot of container from `docker ps`
- Browser screenshot: `http://<ip>:9090/...` working

---

**Youâ€™re done!** You now have a reproducible pipeline that turns a Java web app into a Dockerized Tomcat service, built and shipped by Jenkins.

